<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link type="text/css" rel="stylesheet" href="style.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix.js">
    </script>
    <script src="canvas-gl.js"></script>
    <title>Government Website</title>
    <!-- add in glMatrix js

    also: "out" is OK!


    +++ CLEAN UP THE GLSL -->

    <!--
      This pair of scripts helps define the motion for the "wedge sphere," comprised of extruded
      polygons. Each polygon is actually a wedge shape that grows and shrinks based on random noise.
    -->
    <script id="vertex-wedge" type="vertex-shader">
      #define PI 3.1415926536
      #define DEPTH 0.156

      precision highp float;
      precision mediump int;

      attribute vec4 aPosition;
      attribute vec4 aNormal;
      attribute vec4 aWedgeNormal;

      varying vec4 vNormal;
      varying vec4 vPosition;
      varying vec4 vWedgeNormal;
      varying vec3 vColor;
      varying float cullLength;

      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 projectionMatrix;  // add in view matrix to projection matrix
      uniform mat4 normalMatrix;

      uniform vec3 uAccent;
      uniform vec3 uBackground;

      uniform float iTime;

      // note: animation, color, ... can all be calculated in the vertex shader
      //       using the vWedgeNormal value (saves time + energy :)

      // unite all the green constants
      // bring them towards the green of the page

      const float HEIGHTMOD = (1.0 - (DEPTH / 2.0));

      // modification of the "ubiquitous celebrity"
      float rand(vec3 coord) {
        return (fract(sin(dot(coord, vec3(628.9797, 895.233, 892.1146))) * 43758.5453));
      }

      float fade(float t) {
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
      }

      float easeOut(float t) {
        return pow(t, 1.0); // something that pops
      }

      void main() {
        float goalTime = ceil(iTime);
        float fadeCurve = fade(fract(iTime));
        vec3 initVec = vec3(floor(iTime)) + aWedgeNormal.xyz;
        vec3 goalVec = vec3(goalTime) + aWedgeNormal.xyz;
        // vec3 colorInit = vec3(floor(iTime)) - aWedgeNormal.xyz;
        // vec3 colorGoal = vec3(ceil(iTime)) - aWedgeNormal.xyz;
        float ratio = HEIGHTMOD + mix((DEPTH * rand(initVec)), (DEPTH * rand(goalVec)), fadeCurve);
        //vColor = (rand(colorInit) > 0.5 ? GREEN : GRAY);
        vColor = mix(uBackground * 2.0, uAccent, min(pow(mix(rand(initVec), rand(goalVec), fract(iTime)) + 0.4, 32.0), 1.0));
        vec4 modelTransform = modelMatrix * vec4(aPosition.xyz * ratio, aPosition.w);
        vPosition = modelTransform;
        cullLength = length(aPosition);
        vNormal = normalMatrix * aNormal * (ratio > 0.0 ? 1. : -1.);
        vWedgeNormal = normalMatrix * aWedgeNormal;  // consistently pass it on to the frag shader
        gl_Position = projectionMatrix * viewMatrix * modelTransform;
      }
    </script>
    <script id="fragment-wedge" type="fragment-shader">

      precision highp float;
      precision mediump int;

      struct PointLight {
        vec3 worldPosition;
        vec3 color;
        float intensity;
      };

      varying vec4 vNormal;
      varying vec4 vPosition;
      varying vec4 vWedgeNormal;
      varying vec3 vColor;
      varying float cullLength;

      uniform float uAmbientStrength;
      const float specFalloff = 8.0;
      const float specIntensity = 0.3;

      uniform vec3 uCameraPosition;  // first step: turn it green
      uniform vec3 uGeometryColor;

      uniform PointLight uLight;

      const float WEDGE_MAG = 1.41;

      // todo: switch out diffuse/spec for pbr alternatives

      // currently lambertian, replace with oren nayar
      vec3 diffuseGeometry(vec4 pos, vec4 norm, PointLight light) {
        vec3 posToLight = normalize(light.worldPosition - pos.xyz);
        return max(dot(posToLight, normalize(norm.xyz)), 0.0) * light.color;
      }

      vec3 specularGeometry(vec4 pos, vec4 norm, PointLight light) {
        vec3 posToEye = normalize(uCameraPosition.xyz - pos.xyz);
        vec3 posToLight = normalize(light.worldPosition.xyz - pos.xyz);  // cam position need not be passed
        vec3 halfway = normalize(posToEye + posToLight);
        return pow(max(dot(halfway, norm.xyz), 0.0), specFalloff) * light.color * specIntensity;
      }

      // final lighting color multiplied by material color (reflectance * incoming)

      void main() {
        if (cullLength >= WEDGE_MAG) {
          vec3 trueColor = vColor;
          vec3 diffuse = diffuseGeometry(vPosition, vNormal, uLight);
          vec3 specular = specularGeometry(vPosition, vNormal, uLight);
          vec3 outputColor = vec3(uAmbientStrength) + (diffuse + specular) * uLight.intensity;
          gl_FragColor = vec4((outputColor * trueColor), 1);  // this should be ok
        }
      }
    </script>
    <!--
      This script defines the shading of the icosphere "particles" which float about recklessly
      in the background. Simple blinn-phong shading model, will switch out with something
      else someday.
    -->
    <script id="vertex-particle" type="vertex-shader">
      // probably ok to gouraud shade these

      precision highp float;

      // copied from fragment-wedge
      struct PointLight {
        vec3 worldPosition;
        vec3 color;
        float intensity;
      };

      attribute vec4 aPosition;
      attribute vec4 aNormal;

      varying vec3 vVertexColor;
      // figure out what to do for color

      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 projectionMatrix;
      uniform mat4 normalMatrix;

      uniform PointLight uLight;

      uniform vec3 uCameraPosition;
      uniform vec3 uGeometryColor;

      uniform float uAmbientStrength;

      const float specFalloff = 32.0;

      vec3 diffuseGeometry(vec4 pos, vec4 norm, PointLight light) {
        vec3 posToLight = light.worldPosition - pos.xyz;
        float distance = length(posToLight) / 1.5;
        return max(dot(normalize(norm.xyz), normalize(posToLight)) / pow(distance, 0.5), 0.0) * light.color;  // not necessary to normalize again, should be done
      }

      vec3 specularGeometry(vec4 pos, vec4 norm, PointLight light) {
        vec3 posToEye = normalize(uCameraPosition - pos.xyz);
        vec3 posToLight = normalize(light.worldPosition - pos.xyz);
        vec3 halfway = normalize(posToEye + posToLight);
        return pow(max(dot(normalize(norm.xyz), halfway), 0.0), 4.0) * light.color * 0.2;
      }

      void main() {
        vec4 modelPosition = modelMatrix * aPosition;
        vec4 modelNormal = normalize(normalMatrix * aNormal);
        vec3 color = (vec3(uAmbientStrength) + diffuseGeometry(modelPosition, modelNormal, uLight)) * uGeometryColor;
        vVertexColor = color;
        gl_Position = projectionMatrix * viewMatrix * modelPosition;
      }

      // side note: these functions are not very interesting. look into doing something interesting with the geometry
    </script>
    <script id="fragment-particle" type="fragment-shader">
    precision highp float;

    varying vec3 vVertexColor;

    void main() {
      gl_FragColor = vec4(vVertexColor, 1.0);
    }
    </script>

    <script id="vertex-frame" type="vertex-shader">
    attribute vec2 aTexCoord;
    attribute vec4 aPosition;

    varying vec2 vTexCoord;

    void main() {
      vTexCoord = aTexCoord;
      gl_Position = aPosition;
    }
    </script>
    <!-- now that i can: would like to add some filters for fun -->
    <script id="fragment-frame" type="fragment-shader">
    #define GAMMA 2.2

    #define EDGE_THRESHOLD_MIN 0.0312
    #define EDGE_THRESHOLD_MAX 0.125
    #define ITERATIONS 16

    precision highp float;

    varying vec2 vTexCoord;

    uniform sampler2D uBuffer;

    uniform float iTime;  // hehe

    uniform vec2 resolution; // might not have to worry here

    const vec3 gammaVector = vec3(1.0 / GAMMA);

    // fxaa: http://blog.simonrodriguez.fr/articles/30-07-2016_implementing_fxaa.html

    float fade(float t) {
      return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
    }

    // no alpha so multiply by alpha to get relative brightness
    float lumaRgba(vec4 col) {
      return dot(col.rgb, vec3(0.299, 0.587, 0.114)); // skipping gamma for now
    }

    // rewrite fxaa later

    void main() {
      vec4 colorOutput = texture2D(uBuffer, vTexCoord);
      float yPosition = gl_FragCoord.y / resolution.y;
      if (yPosition < 0.10) {
        colorOutput.a = fade(yPosition * 10.0) * colorOutput.a;
      } else if (yPosition > 0.75) {
        colorOutput.a = fade((1.0 - yPosition) * 4.0) * colorOutput.a;
      }
      gl_FragColor = vec4(colorOutput.rgb, (iTime >= 0.5 ? colorOutput.a : iTime * 2.0 * colorOutput.a));
    }
    </script>
  </head>
  <body>
    <header>
      <div id="header-box">
        <h2><span>g</span>overnment</h2>
        <div id="highlight-container">
          <h2 class="highlight"><span>g</span>overnment</h2>
        </div>
        <!-- this sucks, clean up IDs and classes -->
        <div id="highlight-container-two">
          <h2 class="highlight"><span>g</span>overnment</h2>
        </div>
      </div>
      <nav>
        <div class="menu-item">
          <div class="bullet-node hidden">
          </div>
          <span class="hidden">about</span>
        </div>
        <div class="menu-item">
          <div class="bullet-node hidden">
          </div>
          <span class="hidden">help</span>
        </div>
        <div class="menu-item">
          <div class="bullet-node hidden">
          </div>
          <span class="hidden">support</span>
        </div>
      </nav>
    </header>
    <canvas width=1920 height=720 class="canvas-header" id="primary-canvas">  <!--Size based on window, leave some room as well.-->
    </canvas>
  </body>
</html>
