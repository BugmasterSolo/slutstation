import asyncio
import aiohttp
import multiprocessing
from PIL import Image
from .base import Module, Command
from io import BytesIO
from discord import File


# Ideally, this will help manage processing several images at a time
# Apply operations in PIL. Once they're done, run the post function in a
# separate environment (no await!)

# no async in treads! (some threadsafe aio functions to get around it)
class ImageQueue:
    def __init__(self):
        # self.queue = multiprocessing.queues.Queue()
        pass

    async def _post(data, chan, filename="upload.png"):
        img = BytesIO()
        data.save(img, "PNG")
        # check file size before sending
        img.seek(0)
        print("sending file...")
        chan.send(file=File(img, filename=filename))

    async def _load_image(url):
        print("get image: " + url)
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                data = await resp.read()
        try:
            img = await asyncio.get_event_loop.run_in_executor(None, Image.open(BytesIO(data)))  # should be fine
            return img
        except IOError:
            print("Failed to load image.")  # replace with HCI error
            return None  # deft error handling (functions should watch out for error case


class Pixelsorter:
    def get_data(img):
        data = img.load()
        print(data)  # array
        return data

    def luma(pix):  # Pillow returns 3-tupless representing pixels
        return 0.2126 * pix[0] + 0.7152 * pix[1] + 0.0722 * pix[2]

    def pixelsort(data, size, threshold, pool, comparison_function=luma):
        '''
Performs a pixel sort on some imported image data, using threshold as a base, and using comparison_function and direction to determine whether a pixel should be sorted.

PixelAccess data                - An object generated by Pillow which contains the image's RGBA data.
Integer[2] size                 - Width and height of the current image.
Float threshold                 - The absolute threshold (0 to 1) determining when a pixel should be sorted.
multiprocessing.Pool pool       - A multiprocessing pool from which the operation can be instantiated.
Function comparison_function    - The function used to evaluate the threshold value for a given pixel. Should accept a 3-tuple and return a float value from 0 to 1.
        '''
        mp_data = multiprocessing.Array("H", size[0] * size[1], lock=True)
        pool.map_async(lambda r: sort_row(mp_data, data, r, size[0], threshold, comparison_function), range(size[1]))  # callback should post the image to the provided channel
        pass


def sort_row(mp_data, read_data, row, len, threshold, comparison_function):
    '''
Sorts a single row of an image. Reads from the generated image data at read_data, computes the sorted pixels using the comparison_function,
and inserts them into multiprocessing array mp_data (which should provide a lock).

multiprocessing.Array mp_data   - A multiprocessing array which provides a lock.
PixelAccess read_data           - The original image. Read-only.
Integer row                     - The row which is being read from.
Integer len                     - Integer specifying the length of each row. Assuredly helpful :)
Float threshold                 - The cutoff which determines whether or not the pixel will be sorted. Always tests greater than, so if necessary define a lambda to get the inverse.
Function comparison_function    - The function used to compare values when sorting.
    '''
    cur = 0
    while cur < len:
        val = comparison_function(read_data[cur, row])
        if val > threshold:
            start = cur
            data_array = []
            while val > threshold and cur < len:
                data_array.append([val, read_data[cur, row]])  # data array holds value/threshold pairs. we will sort by val
                cur += 1
                val = comparison_function(read_data[cur, row])
            data_array = sorted(data_array, lambda val: val[0])  # sort using val in index 0
            with mp_data.get_lock():
                for val in range(len(data_array)):
                    mp_data[row * len + start + val] = data_array[val][1]
        else:
            with mp_data.get_lock():
                mp_data[row * len + cur] = read_data[cur, row]
            cur += 1


class ImageModule(Module):
    # the imageQueue is a means of managing a longer list of image commands. users may stack it high and they need to be managed
    # look into spawning threads and letting them run as asynchronous events so as to avoid blocking the main thread
    # for now: create a single queue that just cranks out images as necessary and prints them with done
    # later on: look into creating several queues
    # threading should be aware of the processor limitations as well

    def __init__(self, host, *args, **kwargs):
        self.queue = asyncio.Queue()
        super().__init__(host, *args, **kwargs)
